1. **Описание задачи:**

Текущая задача состоит в выборке данных из таблицы `subordination` для формирования списка сотрудников того же офиса по айди одного из них.

Таблица представлена в виде иерархической (древовидной) структуры, которая содержит идентификаторы, идентификаторы родителя, наименования офисов, отделов, подотделов, имена сотрудников, а также тип обьекта.

2. **Текущая сложность:**

В результате выполнения выборки данных, запрос проходит количество шагов равное глубине иерархии, при очень глубокой иерархии это может стать проблемой.
Так же такой способ не предполагает двойного назначения (например не получится создать сотрудника который находится сразу в двух отелах)
При всем этом из чисто полезной информации есть только один столбец *name*, что ограничивает подробность хранимой информации

Выбрать все дочерние элементы просто: SELECT WHERE parent_id = ?, но другие операции требуют выполнения нескольких запросов и на больших деревьях особо неэффективны.
Например, выбор всех потомков элемента с идентификатором :id
выбрать список детей :id (SELECT WHERE parent_id = :id)
выбрать список их детей (SELECT WHERE parent_id IN (:children1))
выбрать список детей детей (SELECT WHERE parent_id IN (:children2))
И так, пока мы не дойдем до самого нижнего элемента. После этого надо еще отсортировать и объединить результаты в дерево.

Использование рекурсивной функции позволило адаптировать запрос, позволив подниматься и опускаться не имея представления о глубине иерархии
Плюсом, впрочем, является быстрая вставка и перемещение веток, которые не требуют никаких дополнительных запросов, и простота реализации. Если можно эффективно кешировать выборки, это в общем-то нормальный и работающий вариант (например, для меню сайта).

---

**Предложения по оптимизации выборки SQL:**

1. **Индексирование:**

Можно создать параметр *depht* - показывающий глубину вложенности

2. **Использование более сложных методов:**

2) Closure table — усовершенствование существующего способа

В этом способе мы так же добавляет поле parent_id, но для оптимизации рекурсивных выборок создаем дополнительную таблицу,
в которой для каждого исходного элемента храним всех его потомков и их глубину относительно него.


Число строк в этой таблице примерно равно (число элементов) × (среднее число потомков у элемента), то есть их будет довольно много и для больших таблиц (тысячи и больше элементов) этот подход неэффективен.
Чтобы узнать всех потомков записи, мы (в отличие от предыдущего способа), делаем запрос к дополнительной таблице: SELECT child_id FROM closure_table WHERE parent_id = :id,
получаем id потомков и выбираем их их основной таблицы: SELECT WHERE id IN (:children). Если таблицы хранятся в одной БД, запросы можно объединить в один с использованием JOIN.
Данные потом надо будет вручную отсортировать в дерево.

Узнать список предков можно тоже одним запросом к таблице связей: SELECT parent_id FROM closure_table WHERE child_id = :id ORDER BY depth

Минусы метода:

нужно поддерживать таблицу связей, она может быть огромной

при вставке новых записей и при перемещении веток нужны сложные манипуляции с удалением, изменением и вставкой большого числа записей. Если таблица часто меняется, это не лучший способ.

записи нужно сортировать после выборки

Плюсы:

относительная простота

быстрота выборок (если не учитывать сортировку)


3) Nested sets

Идея в том, что мы добавляем к каждой записи поля parent_id, depth, left, right и выстраиваем записи особым образом.
Поля left и right хранят идущие по возрастанию числа, подобранные, чтобы соблюдались правила:

значения left/right уникальны и не повторяются
у любого элемента right > left
у детей leftchild и rightchild всегда находятся в промежутке между leftparent и rightparent родителя, то есть leftparent < leftchild < rightchild < rightparent
элементы на одном уровне (с общим родителем) выстраиваются по возрастанию left

Такое распределение чисел позволяет при выборке с условием  ORDER BY left получать отсортированные в правильном порядке записи (попробуй проверить это вручную), и отсеивать потомков записи по условию WHERE left > :leftParent AND right < :rightParent или (что равносильно предыдущему варианту, но использует индекс по left) WHERE left > :leftParent AND left < :rightParent. Индекс по left оптимизирует как сортировку, так и отбор потомков.

Как выбрать всех предков записи с использованием left и right, оставлю в качестве упражнения читателю.

Минусы:

необходимость пересчитывать left/right почти во всей таблице при вставке записей в середину или удалении
сложное перемещение веток
сложность в понимании.
Плюсы:

скорость выборки
записи выбираются уже отсортированными
После этого выборка всех потомков (причем уже отсортированных в нужном порядке) делается простым запросом вида SELECT WHERE left >= :a AND right left
Так как у детей leftchild и rightchild всегда находятся в промежутке между leftparent и rightparent родителя, то есть leftparent